#!/bin/sh
##################################
# remove orphans
##################################
orphan() {
  local -a pkgs
  pkgs=($(paru -Qdtq))         # collect orphans into array
  if (( ${#pkgs[@]} )); then
    paru -Rns "${pkgs[@]}"     # remove them
  else
    echo "No orphan packages found."
  fi
}

############################################
# WTF (What The Fuck is that command?)
############################################
whatcmd() {
  local x="$1"
  [[ -z $x ]] && { echo "usage: whatcmd <name-or-path>"; return 2; }

  # direct path given or file exists in cwd
  if [[ $x == */* || -e $x ]]; then
    local p="${x:A}"
    if [[ -e $p ]]; then
      local kind; kind=$(file -b -- "$p")
      echo "it is a file (${kind}), located in $p"
      return 0
    fi
  fi

  # is it an alias?
  if alias "$x" >/dev/null 2>&1; then
    local a; a=$(alias "$x")
    echo "It is an alias, located in shell: $a"
    return 0
  fi

  # is it a function?
  if typeset -f "$x" >/dev/null 2>&1; then
    zmodload -F zsh/parameter 2>/dev/null || true
    local src="${functions_source[$x]:-shell}"
    echo "It is a shell function, located in ${src}"
    return 0
  fi

  # is it a builtin / reserved word?
  if whence -w "$x" >/dev/null 2>&1; then
    local desc; desc=$(whence -w "$x")
    case "$desc" in
      *"shell builtin"*)
        echo "It is a shell builtin, located in shell"; return 0 ;;
      *"reserved word"*)
        echo "It is a reserved word, located in shell"; return 0 ;;
    esac
  fi

  # is it a external command?
  if command -v -- "$x" >/dev/null 2>&1; then
    local p; p=$(command -v -- "$x")
    echo "It is a program, located in $p"
    return 0
  fi

  # is it a manpage but no command?
  if man -w "$x" >/dev/null 2>&1; then
    local mp; mp=$(man -w "$x" | head -n1)
    echo "it's a man page, located in $mp"
    return 1
  fi

  echo "What is this?"
  return 127
}

# alias
alias wtf='whatcmd'


######################
# MAN! WHAT CAN I SAY!
# script to view manual pages in pdf, and search them in dmenu. idea was stole from luke smith's video and added some features
######################
man() {
    if [ $# -eq 0 ]; then
        # search in dmenu if only type "man"
        local page=$(command man -k . | dmenu -l 30 | awk '{print $1}')
        [ -n "$page" ] && command man -Tpdf "$page" 2>/dev/null | zathura - 2>/dev/null
    else
        # man + xxx to directly open pdf manual
        if command man -w "$@" >/dev/null 2>&1; then
            command man -Tpdf "$@" 2>/dev/null | zathura - 2>/dev/null
        fi
    fi
}

######################
# FZF TOOL
# Fuzzy finder with rich previews — crisp images via ueberzugpp (fallback: chafa),
# video thumbnails, syntax-highlighted text.
# Auto-skips large (>10 MB) and binary files for safety.
#
# Dependencies:
#   required : fzf, fd, bat, ripgrep
#   images   : ueberzugpp (crisp) or chafa (text-based fallback)
#   video    : ffmpegthumbnailer
#
# Commands:
#   ff [query]  — fuzzy file finder
#   fg [query]  — live ripgrep
#
# Keybindings inside fzf:
#   enter       open file (nvim / nsxiv / mpv / zathura)
#   ctrl-y      copy absolute path to clipboard and exit
#   ctrl-o      cd into parent directory and exit
#   ctrl-p      show absolute path in preview pane
#   ctrl-/      toggle preview panel
#   ctrl-d / u  scroll preview down / up
######################

SELF=${(%):-%x}

# ── Helpers ───────────────────────────────────────────────────────

_fzf_to_clipboard() {
    if command -v wl-copy &>/dev/null; then
        printf '%s' "$1" | wl-copy
    elif command -v xclip &>/dev/null; then
        printf '%s' "$1" | xclip -selection clipboard
    elif command -v xsel &>/dev/null; then
        printf '%s' "$1" | xsel --clipboard --input
    elif command -v pbcopy &>/dev/null; then
        printf '%s' "$1" | pbcopy
    else
        echo "[!] No clipboard utility found (need wl-copy, xclip, xsel, or pbcopy)" >&2
        return 1
    fi
}

_fzf_abspath() {
    local file="${1%%:*}"
    realpath -- "$file" 2>/dev/null \
        || printf '%s/%s' "$(cd "$(dirname -- "$file")" && pwd)" "$(basename -- "$file")"
}

_fzf_opener() {
    local file="${1%%:*}"
    local line="${1##*:}"
    [[ ! -e "$file" ]] && return 1

    case "${file:l}" in
        *.png|*.jpg|*.jpeg|*.gif|*.webp|*.bmp|*.tiff)
            setsid -f nsxiv "$file" >/dev/null 2>&1 ;;
        *.mp4|*.mkv|*.webm|*.avi|*.mov)
            setsid -f mpv "$file" >/dev/null 2>&1 ;;
        *.pdf)
            setsid -f zathura "$file" >/dev/null 2>&1 ;;
        *)
            if [[ "$line" =~ ^[0-9]+$ && "$line" != "$file" ]]; then
                nvim "+$line" "$file"
            else
                nvim "$file"
            fi ;;
    esac
}

# ── ueberzugpp ────────────────────────────────────────────────────
# Same FIFO + layer pattern as lfub:
#   • parent keeps fd 3 open on the FIFO so the pipe stays alive
#   • preview sub-processes write JSON commands to the FIFO by path
#   • fzf itself runs with 3>&- (doesn't need the fd)

_fzf_ub_clear() {
    [[ -n "$FIFO_UEBERZUG" && -p "$FIFO_UEBERZUG" ]] || return 0
    printf '{"action":"remove","identifier":"fzf-preview"}\n' \
        > "$FIFO_UEBERZUG" 2>/dev/null
}

_fzf_ub_draw() {
    [[ -n "$FIFO_UEBERZUG" && -p "$FIFO_UEBERZUG" ]] || return 1
    local file="$1"
    local abspath
    abspath=$(realpath -- "$file" 2>/dev/null) || abspath="$PWD/$file"

    # escape backslashes and double-quotes for JSON
    local jp="${abspath//\\/\\\\}"
    jp="${jp//\"/\\\"}"

    # preview-pane position — use fzf 0.54+ vars if available, else calculate
    # for --border=rounded --preview-window='right:62%,border-left'
    local cols=${COLUMNS:-$(tput cols)}
    local x y
    if [[ -n "$FZF_PREVIEW_LEFT" ]]; then
        x=$FZF_PREVIEW_LEFT  y=${FZF_PREVIEW_TOP:-1}
    else
        x=$(( cols - FZF_PREVIEW_COLUMNS - 1 ))
        y=1
    fi

    printf '{"action":"add","identifier":"fzf-preview","x":%d,"y":%d,"width":%d,"height":%d,"scaler":"contain","path":"%s"}\n' \
        "$x" "$y" "$FZF_PREVIEW_COLUMNS" "$FZF_PREVIEW_LINES" "$jp" \
        > "$FIFO_UEBERZUG" 2>/dev/null
}

_fzf_ub_start() {
    [[ -n "$SSH_CLIENT" || -n "$SSH_TTY" ]] && return 1
    local ub
    if   command -v ueberzugpp &>/dev/null; then ub=ueberzugpp
    elif command -v ueberzug   &>/dev/null; then ub=ueberzug
    else return 1; fi

    [[ ! -d "$HOME/.cache/fzf" ]] && mkdir -p "$HOME/.cache/fzf"
    export FIFO_UEBERZUG="$HOME/.cache/fzf/ueberzug-$$"
    rm -f "$FIFO_UEBERZUG" 2>/dev/null        # clean stale fifo
    mkfifo "$FIFO_UEBERZUG"
    $ub layer -s < "$FIFO_UEBERZUG" -p json &
    _FZF_UB_PID=$!
    exec 3>"$FIFO_UEBERZUG"                   # keep pipe alive
}

_fzf_ub_stop() {
    exec 3>&- 2>/dev/null
    if [[ -n "$_FZF_UB_PID" ]]; then
        kill "$_FZF_UB_PID" 2>/dev/null
        wait "$_FZF_UB_PID" 2>/dev/null
    fi
    [[ -p "$FIFO_UEBERZUG" ]] && rm -f "$FIFO_UEBERZUG"
    rm -f "$HOME/.cache/fzf/thumb-$$.jpg" 2>/dev/null
    unset FIFO_UEBERZUG _FZF_UB_PID
}

# ── Previewer ─────────────────────────────────────────────────────

_fzf_previewer() {
    local file="${1%%:*}"
    local line="${1##*:}"
    local fl="${file:l}"

    # always clear the previous image overlay first
    _fzf_ub_clear

    if [[ -d "$file" ]]; then
        ls -A --color=always "$file"; return
    fi
    [[ -e "$file" ]] || { printf '\033[31m[!] Not found: %s\033[0m\n' "$file"; return; }

    # size guard (non-media only; media previews are lightweight)
    if [[ -f "$file" \
        && ! "$fl" =~ \.(png|jpg|jpeg|gif|webp|bmp|tiff|mp4|mkv|webm|avi|mov)$ ]]; then
        local sz
        sz=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
        if (( sz > 10000000 )); then
            printf '\033[31m[!] File too large for preview (>10 MB)\033[0m\n'; return
        fi
    fi

    # binary guard (non-media only)
    if [[ ! "$fl" =~ \.(png|jpg|jpeg|gif|webp|bmp|tiff|mp4|mkv|webm|avi|mov|pdf)$ ]]; then
        if ! grep -qI . "$file" 2>/dev/null; then
            printf '\033[33m[!] Binary file – preview skipped\033[0m\n'; return
        fi
    fi

    # ── render ──
    if [[ "$fl" =~ \.(png|jpg|jpeg|gif|webp|bmp|tiff)$ ]]; then
        _fzf_ub_draw "$file" && return
        # fallback: chafa (SSH / no ueberzugpp)
        chafa -c full --color-space rgb \
            -s "${FZF_PREVIEW_COLUMNS}x${FZF_PREVIEW_LINES}" "$file"

    elif [[ "$fl" =~ \.(mp4|mkv|webm|avi|mov)$ ]]; then
        local thumb="$HOME/.cache/fzf/thumb-$$.jpg"
        ffmpegthumbnailer -i "$file" -o "$thumb" -s 0 -q 5 >/dev/null 2>&1 || return
        if _fzf_ub_draw "$thumb"; then return; fi   # thumb cleaned in _fzf_ub_stop
        chafa -c full --color-space rgb \
            -s "${FZF_PREVIEW_COLUMNS}x${FZF_PREVIEW_LINES}" "$thumb"
        rm -f "$thumb"

    else
        if [[ "$line" =~ ^[0-9]+$ && "$line" != "$file" ]]; then
            bat --style=numbers --color=always --highlight-line "$line" "$file"
        else
            bat --style=numbers --color=always "$file"
        fi
    fi
}

# ── Dispatcher (fzf sub-processes call: zsh <SELF> <action> <arg>) ──

case "$1" in
    --preview)  _fzf_previewer "$2"; return 0 ;;
    --open)     _fzf_opener "$2";    return 0 ;;
    --abspath)
        _fzf_ub_clear
        printf '\033[1;36mAbsolute path:\033[0m\n'
        _fzf_abspath "$2"
        return 0 ;;
    --copy-path)
        local _p; _p=$(_fzf_abspath "$2")
        _fzf_to_clipboard "$_p"
        return 0 ;;
esac

# ── ff — fuzzy file finder ───────────────────────────────────────

_ff_func() {
    local query="$*"
    local header='enter: open │ ^y: yank path │ ^o: open dir │ ^p: path │ ^/: preview'

    _fzf_ub_start
    local result
    {
        result=$(fd --type f --hidden --follow --strip-cwd-prefix --exclude .git | \
            fzf --query "$query" \
                --scheme=path \
                --preview "zsh '${SELF}' --preview {}" \
                --layout=reverse \
                --border=rounded \
                --height=100% \
                --info=inline-right \
                --header "$header" \
                --preview-window='right:62%,border-left' \
                --bind 'ctrl-/:toggle-preview' \
                --bind 'ctrl-d:preview-half-page-down' \
                --bind 'ctrl-u:preview-half-page-up' \
                --bind "ctrl-p:preview(zsh '${SELF}' --abspath {})" \
                --bind "ctrl-y:become(printf '__COPY__:%s' {})" \
                --bind "ctrl-o:become(printf '__DIR__:%s' {})" \
                --bind "enter:become(printf '__OPEN__:%s' {})" \
                3>&-
        )
    } always {
        _fzf_ub_stop
    }

    case "$result" in
        __COPY__:*)
            local abs; abs=$(_fzf_abspath "${result#__COPY__:}")
            _fzf_to_clipboard "$abs" \
                && printf 'Copied: %s\n' "$abs" \
                || printf '%s\n' "$abs"
            ;;
        __DIR__:*)
            local target="${result#__DIR__:}"
            local dir
            [[ -d "$target" ]] && dir="$target" || dir=$(dirname -- "$target")
            cd -- "$dir" && printf 'cd: %s\n' "$(pwd)"
            ;;
        __OPEN__:*)
            _fzf_opener "${result#__OPEN__:}"
            ;;
    esac
}

# ── fg — live ripgrep ────────────────────────────────────────────

_fg_func() {
    local query="$*"
    local header='enter: open │ ^y: yank path │ ^o: open dir │ ^p: path │ ^/: preview'
    local RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case"

    _fzf_ub_start
    local result
    {
        result=$(fzf --ansi --disabled --query "$query" \
            --bind "start:reload:$RG_PREFIX {q} || true" \
            --bind "change:reload:sleep 0.05; $RG_PREFIX {q} || true" \
            --delimiter : \
            --preview "zsh '${SELF}' --preview {1}:{2}" \
            --layout=reverse \
            --border=rounded \
            --height=100% \
            --info=inline-right \
            --header "$header" \
            --preview-window='right:62%,border-left' \
            --bind 'ctrl-/:toggle-preview' \
            --bind 'ctrl-d:preview-half-page-down' \
            --bind 'ctrl-u:preview-half-page-up' \
            --bind "ctrl-p:preview(zsh '${SELF}' --abspath {1})" \
            --bind "ctrl-y:become(printf '__COPY__:%s' {1})" \
            --bind "ctrl-o:become(printf '__DIR__:%s' {1})" \
            --bind "enter:become(printf '__OPEN__:%s:%s' {1} {2})" \
            3>&-
        )
    } always {
        _fzf_ub_stop
    }

    case "$result" in
        __COPY__:*)
            local abs; abs=$(_fzf_abspath "${result#__COPY__:}")
            _fzf_to_clipboard "$abs" \
                && printf 'Copied: %s\n' "$abs" \
                || printf '%s\n' "$abs"
            ;;
        __DIR__:*)
            local target="${result#__DIR__:}"
            local dir
            [[ -d "$target" ]] && dir="$target" || dir=$(dirname -- "$target")
            cd -- "$dir" && printf 'cd: %s\n' "$(pwd)"
            ;;
        __OPEN__:*)
            _fzf_opener "${result#__OPEN__:}"
            ;;
    esac
}

# ── Aliases ──────────────────────────────────────────────────────
alias ff='noglob _ff_func'
alias fg='noglob _fg_func'   # ⚠ shadows built-in `fg`; rename if you use job control
