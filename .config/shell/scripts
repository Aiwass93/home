##################################
# remove orphans
##################################
orphan() {
  local -a pkgs
  pkgs=($(paru -Qdtq))         # collect orphans into array
  if (( ${#pkgs[@]} )); then
    paru -Rns "${pkgs[@]}"     # remove them
  else
    echo "No orphan packages found."
  fi
}

############################################
# WTF (What The Fuck is that command?)
############################################
whatcmd() {
  local x="$1"
  [[ -z $x ]] && { echo "usage: whatcmd <name-or-path>"; return 2; }

  # direct path given or file exists in cwd
  if [[ $x == */* || -e $x ]]; then
    local p="${x:A}"
    if [[ -e $p ]]; then
      local kind; kind=$(file -b -- "$p")
      echo "it is a file (${kind}), located in $p"
      return 0
    fi
  fi

  # is it an alias?
  if alias "$x" >/dev/null 2>&1; then
    local a; a=$(alias "$x")
    echo "It is an alias, located in shell: $a"
    return 0
  fi

  # is it a function?
  if typeset -f "$x" >/dev/null 2>&1; then
    zmodload -F zsh/parameter 2>/dev/null || true
    local src="${functions_source[$x]:-shell}"
    echo "It is a shell function, located in ${src}"
    return 0
  fi

  # is it a builtin / reserved word?
  if whence -w "$x" >/dev/null 2>&1; then
    local desc; desc=$(whence -w "$x")
    case "$desc" in
      *"shell builtin"*)
        echo "It is a shell builtin, located in shell"; return 0 ;;
      *"reserved word"*)
        echo "It is a reserved word, located in shell"; return 0 ;;
    esac
  fi

  # is it a external command?
  if command -v -- "$x" >/dev/null 2>&1; then
    local p; p=$(command -v -- "$x")
    echo "It is a program, located in $p"
    return 0
  fi

  # is it a manpage but no command?
  if man -w "$x" >/dev/null 2>&1; then
    local mp; mp=$(man -w "$x" | head -n1)
    echo "it's a man page, located in $mp"
    return 1
  fi

  echo "What is this?"
  return 127
}

# alias
alias wtf='whatcmd'


######################
# MAN! WHAT CAN I SAY!
# script to view manual pages in pdf, and search them in dmenu. idea was stole from luke smith's video and added some features
######################
man() {
    if [ $# -eq 0 ]; then
        # search in dmenu if only type "man"
        local page=$(command man -k . | dmenu -l 30 | awk '{print $1}')
        [ -n "$page" ] && command man -Tpdf "$page" 2>/dev/null | zathura - 2>/dev/null
    else
        # man + xxx to directly open pdf manual
        if command man -w "$@" >/dev/null 2>&1; then
            command man -Tpdf "$@" 2>/dev/null | zathura - 2>/dev/null
        fi
    fi
}

######################
# FZF TOOL
# make fuzzy find program actually work, able to preview images and text files, auto skip huge files for safety, auto skip binary files to avoid meaningless content
######################

# capture path for recursive calls
SELF=${(%):-%x}

# helper functions

_fzf_opener() {
    local file="${1%%:*}"
    local line="${1##*:}"
    if [[ ! -e "$file" ]]; then return; fi
    case "$file" in
        *.png|*.jpg|*.jpeg|*.gif|*.webp) setsid -f nsxiv "$file" >/dev/null 2>&1 ;;
        *.mp4|*.mkv|*.webm)             setsid -f mpv "$file" >/dev/null 2>&1 ;;
        *.pdf)                          setsid -f zathura "$file" >/dev/null 2>&1 ;;
        *)
            if [[ "$line" =~ ^[0-9]+$ ]] && [ "$line" != "$file" ]; then
                nvim "+$line" "$file"
            else
                nvim "$file"
            fi
            ;;
    esac
}

_fzf_previewer() {
    local file="${1%%:*}"
    local line="${1##*:}"

    # check files
    if [ -d "$file" ]; then
        ls -A --color=always "$file"
        return
    fi
    # check file size, skip it if too large (default 10mb)
    if [ -f "$file" ] && [ "$(wc -c < "$file")" -gt 10000000 ]; then
        echo -e "\033[31m[!] File too large for preview (>10MB)\033[0m"
        return
    fi
    # check binary files
    if grep -qI . "$file" 2>/dev/null; then
        :
    else
        if [[ ! "$file" =~ \.(png|jpg|jpeg|gif|webp|mp4|mkv|webm|pdf)$ ]]; then
             echo -e "\033[33m[!] Binary file detected - Preview skipped\033[0m"
             return
        fi
    fi
    #########################################

    if [[ "$file" =~ \.(png|jpg|jpeg|gif|webp)$ ]]; then
        chafa -c full --color-space rgb -s "${FZF_PREVIEW_COLUMNS}x${FZF_PREVIEW_LINES}" "$file"
    elif [[ "$file" =~ \.(mp4|mkv|webm)$ ]]; then
        local thumb="/tmp/fzf-thumb.jpg"
        ffmpegthumbnailer -i "$file" -o "$thumb" -s 0 -q 5 >/dev/null 2>&1
        chafa -c full --color-space rgb -s "${FZF_PREVIEW_COLUMNS}x${FZF_PREVIEW_LINES}" "$thumb"
    else
        if [[ "$line" =~ ^[0-9]+$ ]] && [ "$line" != "$file" ]; then
            bat --style=numbers --color=always --highlight-line "$line" "$file"
        else
            bat --style=numbers --color=always "$file"
        fi
    fi
}

# diapatcher
if [[ "$1" == "--preview" ]]; then
    _fzf_previewer "$2"
    return 0
fi
if [[ "$1" == "--open" ]]; then
    _fzf_opener "$2"
    return 0
fi

# main commands

# we use functions with underscores so we can alias them safely

_ff_func() {
    # takes all arguments as the query (you should quote "multi word strings like this")
    local query="$*"

    IFS=$'\n' files=($(fd --type f --hidden --follow --exclude .git | \
        fzf --query "$query" \
            --preview "zsh $SELF --preview {}" \
            --layout=reverse \
            --border \
            --height 100% \
            --preview-window='right:62%,border-left' \
            --bind 'enter:become(echo {})'
    ))
    [[ -n "$files" ]] && _fzf_opener "$files"
}

_fg_func() {
    # take all arguments as the query
    local query="$*"

    rm -f /tmp/rg-fzf-{r,f}
    # we escape quotes to prevent breaking the fzf bind string
    RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "

    fzf --ansi --disabled --query "$query" \
        --bind "start:reload:$RG_PREFIX {q}" \
        --bind "change:reload:$RG_PREFIX {q}" \
        --delimiter : \
        --preview "zsh $SELF --preview {1}:{2}" \
        --layout=reverse \
        --border \
        --height 100% \
        --preview-window 'right:62%,border-left' \
        --bind "enter:execute(zsh $SELF --open {1}:{2})+abort"
}

# aliases
alias ff='noglob _ff_func'
alias fg='noglob _fg_func'
